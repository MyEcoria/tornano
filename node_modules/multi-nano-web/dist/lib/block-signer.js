"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var nano_address_1 = __importDefault(require("./nano-address"));
var nano_converter_1 = __importDefault(require("./nano-converter"));
var signer_1 = __importDefault(require("./signer"));
var convert_1 = __importDefault(require("./util/convert"));
var BlockSigner = /** @class */ (function () {
    function BlockSigner() {
    }
    var _a;
    _a = BlockSigner;
    BlockSigner.preamble = 0x6.toString().padStart(64, '0');
    /**
     * Sign a receive block
     *
     * @param {ReceiveBlock} data The data required to sign a receive block
     * @param {string} privateKey Private key to sign the data with
     * @returns {SignedBlock} the signed block to publish to the blockchain
     */
    BlockSigner.receive = function (data, privateKey) {
        var validateInputRaw = function (input) { return !!input && !isNaN(+input); };
        if (!validateInputRaw(data.walletBalanceRaw)) {
            throw new Error('Invalid format in wallet balance');
        }
        if (!validateInputRaw(data.amountRaw)) {
            throw new Error('Invalid format in send amount');
        }
        if (!nano_address_1.default.validateNanoAddress(data.toAddress)) {
            throw new Error('Invalid toAddress');
        }
        if (!nano_address_1.default.validateNanoAddress(data.representativeAddress)) {
            throw new Error('Invalid representativeAddress');
        }
        if (!data.transactionHash) {
            throw new Error('No transaction hash');
        }
        if (!data.frontier) {
            throw new Error('No frontier');
        }
        if (!privateKey) {
            throw new Error('Please input the private key to sign the block');
        }
        var balanceNano = nano_converter_1.default.convert(data.walletBalanceRaw, 'RAW', 'NANO');
        var amountNano = nano_converter_1.default.convert(data.amountRaw, 'RAW', 'NANO');
        var newBalanceNano = new bignumber_js_1.default(balanceNano).plus(new bignumber_js_1.default(amountNano));
        var newBalanceRaw = nano_converter_1.default.convert(newBalanceNano, 'NANO', 'RAW');
        var newBalanceHex = convert_1.default.dec2hex(newBalanceRaw, 16).toUpperCase();
        var account = nano_address_1.default.nanoAddressToHexString(data.toAddress);
        var link = data.transactionHash;
        var representative = nano_address_1.default.nanoAddressToHexString(data.representativeAddress);
        var signature = signer_1.default.sign(privateKey, _a.preamble, account, data.frontier, representative, newBalanceHex, link);
        return {
            type: 'state',
            account: data.toAddress,
            previous: data.frontier,
            representative: data.representativeAddress,
            balance: newBalanceRaw,
            link: link,
            signature: signature,
            work: data.work || '',
        };
    };
    /**
     * Sign a send block
     *
     * @param {SendBlock} data The data required to sign a send block
     * @param {string} privateKey Private key to sign the data with
     * @returns {SignedBlock} the signed block to publish to the blockchain
     */
    BlockSigner.send = function (data, privateKey) {
        var validateInputRaw = function (input) { return !!input && !isNaN(+input); };
        if (!validateInputRaw(data.walletBalanceRaw)) {
            throw new Error('Invalid format in wallet balance');
        }
        if (!validateInputRaw(data.amountRaw)) {
            throw new Error('Invalid format in send amount');
        }
        if (!nano_address_1.default.validateNanoAddress(data.toAddress)) {
            throw new Error('Invalid toAddress');
        }
        if (!nano_address_1.default.validateNanoAddress(data.fromAddress)) {
            throw new Error('Invalid fromAddress');
        }
        if (!nano_address_1.default.validateNanoAddress(data.representativeAddress)) {
            throw new Error('Invalid representativeAddress');
        }
        if (!data.frontier) {
            throw new Error('Frontier is not set');
        }
        if (!privateKey) {
            throw new Error('Please input the private key to sign the block');
        }
        var balanceNano = nano_converter_1.default.convert(data.walletBalanceRaw, 'RAW', 'NANO');
        var amountNano = nano_converter_1.default.convert(data.amountRaw, 'RAW', 'NANO');
        var newBalanceNano = new bignumber_js_1.default(balanceNano).minus(new bignumber_js_1.default(amountNano));
        var newBalanceRaw = nano_converter_1.default.convert(newBalanceNano, 'NANO', 'RAW');
        var newBalanceHex = convert_1.default.dec2hex(newBalanceRaw, 16).toUpperCase();
        var account = nano_address_1.default.nanoAddressToHexString(data.fromAddress);
        var link = nano_address_1.default.nanoAddressToHexString(data.toAddress);
        var representative = nano_address_1.default.nanoAddressToHexString(data.representativeAddress);
        var signature = signer_1.default.sign(privateKey, _a.preamble, account, data.frontier, representative, newBalanceHex, link);
        return {
            type: 'state',
            account: data.fromAddress,
            previous: data.frontier,
            representative: data.representativeAddress,
            balance: newBalanceRaw,
            link: link,
            signature: signature,
            work: data.work || '',
        };
    };
    return BlockSigner;
}());
exports.default = BlockSigner;
