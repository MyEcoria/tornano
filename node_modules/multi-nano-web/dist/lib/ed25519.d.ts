import Curve25519 from './util/curve25519';
export default class Ed25519 {
    curve: Curve25519;
    X: Int32Array;
    Y: Int32Array;
    L: Uint8Array;
    constructor();
    pack(r: Uint8Array, p: Int32Array[]): void;
    modL(r: Uint8Array, x: Uint32Array | Float64Array): void;
    reduce(r: Uint8Array): void;
    scalarmult(p: Int32Array[], q: Int32Array[], s: Uint8Array): void;
    scalarbase(p: Int32Array[], s: Uint8Array): void;
    /**
     * Generate an ed25519 keypair
     * @param {String} seed A 32 byte cryptographic secure random hexadecimal string. This is basically the secret key
     * @param {Object} Returns sk (Secret key) and pk (Public key) as 32 byte hexadecimal strings
     */
    generateKeys(seed: string): KeyPair;
    /**
     * Convert ed25519 keypair to curve25519 keypair suitable for Diffie-Hellman key exchange
     *
     * @param {KeyPair} keyPair ed25519 keypair
     * @returns {KeyPair} keyPair Curve25519 keypair
     */
    convertKeys(keyPair: KeyPair): KeyPair;
    /**
     * Generate a message signature
     * @param {Uint8Array} msg Message to be signed as byte array
     * @param {Uint8Array} privateKey Secret key as byte array
     * @param {Uint8Array} Returns the signature as 64 byte typed array
     */
    sign(msg: Uint8Array, privateKey: Uint8Array): Uint8Array;
    /**
     * Verify a message signature
     * @param {Uint8Array} msg Message to be signed as byte array
     * @param {Uint8Array} publicKey Public key as byte array
     * @param {Uint8Array} signature Signature as byte array
     * @param {Uint8Array} Returns the signature as 64 byte typed array
     */
    verify(msg: Uint8Array, publicKey: Uint8Array, signature: Uint8Array): boolean;
    private naclSign;
    private cryptoSign;
}
export interface KeyPair {
    privateKey: string;
    publicKey: string;
}
