/**
 * Derived from:
 * - mipher
 * - tweetnacl
 * - ed2curve-js
 *
 * With added types etc
 */
export default class Curve25519 {
    gf0: Int32Array;
    gf1: Int32Array;
    D: Int32Array;
    D2: Int32Array;
    I: Int32Array;
    _9: Uint8Array;
    _121665: Int32Array;
    _0: Uint8Array;
    sigma: Uint8Array;
    minusp: Uint32Array;
    constructor();
    gf(init?: number[]): Int32Array;
    A(o: Int32Array, a: Int32Array, b: Int32Array): void;
    Z(o: Int32Array, a: Int32Array, b: Int32Array): void;
    M(o: Int32Array, a: Int32Array, b: Int32Array): void;
    coreSalsa20(o: Uint8Array, p: Uint8Array, k: Uint8Array, c: Uint8Array): void;
    coreHsalsa20(o: Uint8Array, p: Uint8Array, k: Uint8Array, c: Uint8Array): void;
    S(o: Int32Array, a: Int32Array): void;
    add(p: Int32Array[], q: Int32Array[]): void;
    set25519(r: Int32Array, a: Int32Array): void;
    car25519(o: Int32Array): void;
    sel25519(p: Int32Array, q: Int32Array, b: number): void;
    inv25519(o: Int32Array, i: Int32Array): void;
    neq25519(a: Int32Array, b: Int32Array): boolean;
    par25519(a: Int32Array): number;
    pow2523(o: Int32Array, i: Int32Array): void;
    cswap(p: Int32Array[], q: Int32Array[], b: number): void;
    pack25519(o: Uint8Array, n: Int32Array): void;
    unpack25519(o: Int32Array, n: Uint8Array): void;
    unpackNeg(r: Int32Array[], p: Uint8Array): number;
    vn(x: Uint8Array, xi: number, y: Uint8Array, yi: number, n: number): number;
    /**
     * Internal scalar mult function
     * @param {Uint8Array} q Result
     * @param {Uint8Array} s Secret key
     * @param {Uint8Array} p Public key
     */
    cryptoScalarmult(q: Uint8Array, s: Uint8Array, p: Uint8Array): void;
    cryptoStreamSalsa20Xor(c: Uint8Array, cpos: number, m: Uint8Array, mpos: number, b: number, n: Uint8Array, k: Uint8Array): number;
    cryptoStreamSalsa20(c: Uint8Array, cpos: number, b: number, n: Uint8Array, k: Uint8Array): number;
    add1305(h: Uint32Array, c: Uint32Array): void;
    cryptoOnetimeauth(out: Uint8Array, outpos: number, m: Uint8Array, mpos: number, n: number, k: Uint8Array): number;
    cryptoOnetimeauthVerify(h: Uint8Array, hpos: number, m: Uint8Array, mpos: number, n: number, k: Uint8Array): number;
    cryptoVerify16(x: Uint8Array, xi: number, y: Uint8Array, yi: number): number;
    cryptoBoxBeforenm(k: Uint8Array, y: Uint8Array, x: Uint8Array): void;
    cryptoSecretbox(c: Uint8Array, m: Uint8Array, d: number, n: Uint8Array, k: Uint8Array): 0 | -1;
    cryptoSecretboxOpen(m: Uint8Array, c: Uint8Array, d: number, n: Uint8Array, k: Uint8Array): 0 | -1;
    cryptoStream(c: Uint8Array, cpos: number, d: number, n: Uint8Array, k: Uint8Array): number;
    cryptoStreamXor(c: Uint8Array, cpos: number, m: Uint8Array, mpos: number, d: number, n: Uint8Array, k: Uint8Array): number;
    checkLengths(k: Uint8Array, n: Uint8Array): void;
    checkBoxLengths(pk: Uint8Array, sk: Uint8Array): void;
    checkArrayTypes(...params: any): void;
    secretbox(msg: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array;
    secretboxOpen(box: Uint8Array, nonce: Uint8Array, key: Uint8Array): Uint8Array;
    box(msg: Uint8Array, nonce: Uint8Array, publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array;
    boxOpen(msg: Uint8Array, nonce: Uint8Array, publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array;
    boxBefore(publicKey: Uint8Array, secretKey: Uint8Array): Uint8Array;
    /**
     * Generate the common key as the produkt of sk1 * pk2
     * @param {Uint8Array} sk A 32 byte secret key of pair 1
     * @param {Uint8Array} pk A 32 byte public key of pair 2
     * @return {Uint8Array} sk * pk
     */
    scalarMult(sk: Uint8Array, pk: Uint8Array): Uint8Array;
    /**
     * Generate a curve 25519 keypair
     * @param {Uint8Array} seed A 32 byte cryptographic secure random array. This is basically the secret key
     * @param {Object} Returns sk (Secret key) and pk (Public key) as 32 byte typed arrays
     */
    generateKeys(seed: Uint8Array): {
        sk: Uint8Array;
        pk: Uint8Array;
    };
    /**
     * Converts a ed25519 public key to Curve25519 to be used in
     * Diffie-Hellman key exchange
     */
    convertEd25519PublicKeyToCurve25519(pk: Uint8Array): Uint8Array;
    /**
     * Converts a ed25519 secret key to Curve25519 to be used in
     * Diffie-Hellman key exchange
     */
    convertEd25519SecretKeyToCurve25519(sk: Uint8Array): Uint8Array;
    cryptoHash(out: Uint8Array, m: Uint8Array, n: number): number;
}
