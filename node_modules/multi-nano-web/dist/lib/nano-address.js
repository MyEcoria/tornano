"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
var blakejs_1 = require("blakejs");
var convert_1 = __importDefault(require("./util/convert"));
var NanoAddress = /** @class */ (function () {
    function NanoAddress() {
    }
    NanoAddress.stripAddress = function (address) {
        return address.slice(address.indexOf('_') + 1, -8);
    };
    NanoAddress.readChar = function (char) {
        var idx = this.alphabet.indexOf(char);
        if (idx === -1) {
            throw new Error("Invalid character found: ".concat(char));
        }
        return idx;
    };
    var _a;
    _a = NanoAddress;
    NanoAddress.alphabet = '13456789abcdefghijkmnopqrstuwxyz';
    NanoAddress.prefix = 'nano_';
    NanoAddress.deriveAddress = function (publicKey) {
        var publicKeyBytes = convert_1.default.hex2ab(publicKey);
        var checksum = (0, blakejs_1.blake2b)(publicKeyBytes, undefined, 5).reverse();
        var encoded = _a.encodeNanoBase32(publicKeyBytes);
        var encodedChecksum = _a.encodeNanoBase32(checksum);
        return _a.prefix + encoded + encodedChecksum;
    };
    NanoAddress.encodeNanoBase32 = function (publicKey) {
        var length = publicKey.length;
        var leftover = (length * 8) % 5;
        var offset = leftover === 0 ? 0 : 5 - leftover;
        var value = 0;
        var output = '';
        var bits = 0;
        for (var i = 0; i < length; i++) {
            value = (value << 8) | publicKey[i];
            bits += 8;
            while (bits >= 5) {
                output += _a.alphabet[(value >>> (bits + offset - 5)) & 31];
                bits -= 5;
            }
        }
        if (bits > 0) {
            output += _a.alphabet[(value << (5 - (bits + offset))) & 31];
        }
        return output;
    };
    NanoAddress.addressToPublicKey = function (input) {
        var cleaned = input
            .replace('nano_', '')
            .replace('xrb_', '');
        var publicKeyBytes = NanoAddress.decodeNanoBase32(cleaned);
        return convert_1.default.ab2hex(publicKeyBytes).slice(0, 64);
    };
    NanoAddress.decodeNanoBase32 = function (input) {
        var length = input.length;
        var leftover = (length * 5) % 8;
        var offset = leftover === 0 ? 0 : 8 - leftover;
        var bits = 0;
        var value = 0;
        var index = 0;
        var output = new Uint8Array(Math.ceil((length * 5) / 8));
        for (var i = 0; i < length; i++) {
            value = (value << 5) | _a.readChar(input[i]);
            bits += 5;
            if (bits >= 8) {
                output[index++] = (value >>> (bits + offset - 8)) & 255;
                bits -= 8;
            }
        }
        if (bits > 0) {
            output[index++] = (value << (bits + offset - 8)) & 255;
        }
        if (leftover !== 0) {
            output = output.slice(1);
        }
        return output;
    };
    /**
     * Validates a Nano address with 'nano' and 'xrb' prefixes
     *
     * Derived from https://github.com/alecrios/nano-address-validator
     *
     * @param {string} address Nano address
     */
    NanoAddress.validateNanoAddress = function (address) {
        if (address === undefined) {
            throw Error('Address must be defined.');
        }
        if (typeof address !== 'string') {
            throw TypeError('Address must be a string.');
        }
        var allowedPrefixes = ['nano', 'xrb', 'ban', 'xdg', 'ana', 'paw'];
        var pattern = new RegExp("^(".concat(allowedPrefixes.join('|'), ")_[13]{1}[13456789abcdefghijkmnopqrstuwxyz]{59}$"));
        if (!pattern.test(address)) {
            return false;
        }
        var expectedChecksum = address.slice(-8);
        var publicKey = _a.stripAddress(address);
        var publicKeyBuffer = _a.decodeNanoBase32(publicKey);
        var actualChecksumBuffer = (0, blakejs_1.blake2b)(publicKeyBuffer, null, 5).reverse();
        var actualChecksum = _a.encodeNanoBase32(actualChecksumBuffer);
        return expectedChecksum === actualChecksum;
    };
    NanoAddress.nanoAddressToHexString = function (addr) {
        addr = addr.slice(-60);
        var isValid = /^[13456789abcdefghijkmnopqrstuwxyz]+$/.test(addr);
        if (isValid) {
            var keyBytes = _a.decodeNanoBase32(addr.substring(0, 52));
            var hashBytes = _a.decodeNanoBase32(addr.substring(52, 60));
            var blakeHash = (0, blakejs_1.blake2b)(keyBytes, undefined, 5).reverse();
            if (convert_1.default.ab2hex(hashBytes) == convert_1.default.ab2hex(blakeHash)) {
                var key = convert_1.default.ab2hex(keyBytes).toUpperCase();
                return key;
            }
            throw new Error('Checksum mismatch in address');
        }
        else {
            throw new Error('Illegal characters in address');
        }
    };
    return NanoAddress;
}());
exports.default = NanoAddress;
