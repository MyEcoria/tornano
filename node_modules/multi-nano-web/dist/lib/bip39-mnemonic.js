"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
var crypto_js_1 = require("crypto-js");
var convert_1 = __importDefault(require("./util/convert"));
var util_1 = __importDefault(require("./util/util"));
var words_1 = __importDefault(require("./words"));
var Bip39Mnemonic = /** @class */ (function () {
    function Bip39Mnemonic() {
    }
    var _a;
    _a = Bip39Mnemonic;
    /**
     * Creates a BIP39 wallet
     *
     * @param {string} [entropy] - (Optional) the entropy to use instead of generating
     * @returns {MnemonicSeed} The mnemonic phrase and a seed derived from the (generated) entropy
     */
    Bip39Mnemonic.createWallet = function (entropy, password) {
        if (entropy) {
            if (entropy.length !== 64) {
                throw new Error('Invalid entropy length, must be a 32 bit hexadecimal string');
            }
            if (!/^[0-9a-fA-F]+$/i.test(entropy)) {
                throw new Error('Entopy is not a valid hexadecimal string');
            }
        }
        if (!entropy) {
            entropy = _a.randomHex(32);
        }
        var mnemonic = _a.deriveMnemonic(entropy);
        var seed = _a.mnemonicToSeed(mnemonic, password);
        return {
            mnemonic: mnemonic,
            seed: seed,
        };
    };
    /**
     * Creates an old Nano wallet
     *
     * @param {string} seed - (Optional) the seed to be used for the wallet
     * @returns {MnemonicSeed} The mnemonic phrase and a generated seed if none provided
     */
    Bip39Mnemonic.createLegacyWallet = function (seed) {
        if (seed) {
            if (seed.length !== 64) {
                throw new Error('Invalid entropy length, must be a 32 bit hexadecimal string');
            }
            if (!/^[0-9a-fA-F]+$/i.test(seed)) {
                throw new Error('Entopy is not a valid hexadecimal string');
            }
        }
        if (!seed) {
            seed = _a.randomHex(32);
        }
        var mnemonic = _a.deriveMnemonic(seed);
        return {
            mnemonic: mnemonic,
            seed: seed,
        };
    };
    Bip39Mnemonic.deriveMnemonic = function (entropy) {
        var entropyBinary = convert_1.default.hexStringToBinary(entropy);
        var entropySha256Binary = convert_1.default.hexStringToBinary(_a.calculateChecksum(entropy));
        var entropyBinaryWithChecksum = entropyBinary + entropySha256Binary;
        var mnemonicWords = [];
        for (var i = 0; i < entropyBinaryWithChecksum.length; i += 11) {
            mnemonicWords.push(words_1.default[parseInt(entropyBinaryWithChecksum.substr(i, 11), 2)]);
        }
        return mnemonicWords.join(' ');
    };
    /**
     * Validates a mnemonic phrase
     *
     * @param {string} mnemonic - The mnemonic phrase to validate
     * @returns {boolean} Is the mnemonic phrase valid
     */
    Bip39Mnemonic.validateMnemonic = function (mnemonic) {
        var wordArray = util_1.default.normalizeUTF8(mnemonic).split(' ');
        if (wordArray.length % 3 !== 0) {
            return false;
        }
        var bits = wordArray.map(function (w) {
            var wordIndex = words_1.default.indexOf(w);
            if (wordIndex === -1) {
                return false;
            }
            return (convert_1.default.dec2bin(wordIndex)).padStart(11, '0');
        }).join('');
        var dividerIndex = Math.floor(bits.length / 33) * 32;
        var entropyBits = bits.slice(0, dividerIndex);
        var checksumBits = bits.slice(dividerIndex);
        var entropyBytes = entropyBits.match(/(.{1,8})/g).map(function (bin) { return parseInt(bin, 2); });
        if (entropyBytes.length < 16) {
            return false;
        }
        if (entropyBytes.length > 32) {
            return false;
        }
        if (entropyBytes.length % 4 !== 0) {
            return false;
        }
        var entropyHex = convert_1.default.bytesToHexString(entropyBytes);
        var newChecksum = _a.calculateChecksum(entropyHex);
        var inputChecksum = convert_1.default.binaryToHexString(checksumBits);
        if (parseInt(newChecksum, 16) != parseInt(inputChecksum, 16)) {
            return false;
        }
        return true;
    };
    /**
     * Converts the mnemonic phrase to an old Nano seed
     *
     * @param {string} mnemonic Mnemonic phrase separated by spaces
     */
    Bip39Mnemonic.mnemonicToLegacySeed = function (mnemonic) {
        var wordArray = util_1.default.normalizeUTF8(mnemonic).split(' ');
        var bits = wordArray.map(function (w) {
            var wordIndex = words_1.default.indexOf(w);
            if (wordIndex === -1) {
                return false;
            }
            return (convert_1.default.dec2bin(wordIndex)).padStart(11, '0');
        }).join('');
        var dividerIndex = Math.floor(bits.length / 33) * 32;
        var entropyBits = bits.slice(0, dividerIndex);
        var entropyBytes = entropyBits.match(/(.{1,8})/g).map(function (bin) { return parseInt(bin, 2); });
        var entropyHex = convert_1.default.bytesToHexString(entropyBytes);
        return entropyHex;
    };
    /**
     * Converts the mnemonic phrase to a BIP39 seed
     *
     * @param {string} mnemonic Mnemonic phrase separated by spaces
     */
    Bip39Mnemonic.mnemonicToSeed = function (mnemonic, password) {
        var normalizedMnemonic = util_1.default.normalizeUTF8(mnemonic);
        var normalizedPassword = 'mnemonic' + util_1.default.normalizeUTF8(password);
        return (0, crypto_js_1.PBKDF2)(normalizedMnemonic, normalizedPassword, {
            keySize: 512 / 32,
            iterations: 2048,
            hasher: crypto_js_1.algo.SHA512,
        })
            .toString(crypto_js_1.enc.Hex);
    };
    Bip39Mnemonic.randomHex = function (length) {
        return crypto_js_1.lib.WordArray.random(length).toString();
    };
    Bip39Mnemonic.calculateChecksum = function (entropyHex) {
        var entropySha256 = (0, crypto_js_1.SHA256)(crypto_js_1.enc.Hex.parse(entropyHex)).toString();
        return entropySha256.substr(0, entropySha256.length / 32);
    };
    return Bip39Mnemonic;
}());
exports.default = Bip39Mnemonic;
