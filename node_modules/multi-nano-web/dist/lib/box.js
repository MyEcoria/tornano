"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var base64 = __importStar(require("byte-base64"));
//@ts-ignore
var crypto_js_1 = require("crypto-js");
var ed25519_1 = __importDefault(require("./ed25519"));
var nano_address_1 = __importDefault(require("./nano-address"));
var convert_1 = __importDefault(require("./util/convert"));
var curve25519_1 = __importDefault(require("./util/curve25519"));
var Box = /** @class */ (function () {
    function Box() {
    }
    Box.encrypt = function (message, address, privateKey) {
        if (!message) {
            throw new Error('No message to encrypt');
        }
        var publicKey = nano_address_1.default.addressToPublicKey(address);
        var _a = new ed25519_1.default().convertKeys({
            privateKey: privateKey,
            publicKey: publicKey,
        }), convertedPrivateKey = _a.privateKey, convertedPublicKey = _a.publicKey;
        var nonce = convert_1.default.hex2ab(crypto_js_1.lib.WordArray.random(this.NONCE_LENGTH).toString());
        var encrypted = new curve25519_1.default().box(convert_1.default.decodeUTF8(message), nonce, convert_1.default.hex2ab(convertedPublicKey), convert_1.default.hex2ab(convertedPrivateKey));
        var full = new Uint8Array(nonce.length + encrypted.length);
        full.set(nonce);
        full.set(encrypted, nonce.length);
        return base64.bytesToBase64(full);
    };
    Box.decrypt = function (encrypted, address, privateKey) {
        if (!encrypted) {
            throw new Error('No message to decrypt');
        }
        var publicKey = nano_address_1.default.addressToPublicKey(address);
        var _a = new ed25519_1.default().convertKeys({
            privateKey: privateKey,
            publicKey: publicKey,
        }), convertedPrivateKey = _a.privateKey, convertedPublicKey = _a.publicKey;
        var decodedEncryptedMessageBytes = base64.base64ToBytes(encrypted);
        var nonce = decodedEncryptedMessageBytes.slice(0, this.NONCE_LENGTH);
        var encryptedMessage = decodedEncryptedMessageBytes.slice(this.NONCE_LENGTH, encrypted.length);
        var decrypted = new curve25519_1.default().boxOpen(encryptedMessage, nonce, convert_1.default.hex2ab(convertedPublicKey), convert_1.default.hex2ab(convertedPrivateKey));
        if (!decrypted) {
            throw new Error('Could not decrypt message');
        }
        return convert_1.default.encodeUTF8(decrypted);
    };
    Box.NONCE_LENGTH = 24;
    return Box;
}());
exports.default = Box;
