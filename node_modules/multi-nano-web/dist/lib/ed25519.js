"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
var blakejs_1 = require("blakejs");
var convert_1 = __importDefault(require("./util/convert"));
var curve25519_1 = __importDefault(require("./util/curve25519"));
var util_1 = __importDefault(require("./util/util"));
var Ed25519 = /** @class */ (function () {
    function Ed25519() {
        this.curve = new curve25519_1.default();
        this.X = this.curve.gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]);
        this.Y = this.curve.gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]);
        this.L = new Uint8Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);
    }
    Ed25519.prototype.pack = function (r, p) {
        var CURVE = this.curve;
        var tx = CURVE.gf(), ty = CURVE.gf(), zi = CURVE.gf();
        CURVE.inv25519(zi, p[2]);
        CURVE.M(tx, p[0], zi);
        CURVE.M(ty, p[1], zi);
        CURVE.pack25519(r, ty);
        r[31] ^= CURVE.par25519(tx) << 7;
    };
    Ed25519.prototype.modL = function (r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
            carry = 0;
            for (j = i - 32, k = i - 12; j < k; ++j) {
                x[j] += carry - 16 * x[i] * this.L[j - (i - 32)];
                carry = (x[j] + 128) >> 8;
                x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
            x[j] += carry - (x[31] >> 4) * this.L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for (j = 0; j < 32; j++) {
            x[j] -= carry * this.L[j];
        }
        for (i = 0; i < 32; i++) {
            x[i + 1] += x[i] >>> 8;
            r[i] = x[i] & 0xff;
        }
    };
    Ed25519.prototype.reduce = function (r) {
        var x = new Uint32Array(64);
        for (var i = 0; i < 64; i++) {
            x[i] = r[i];
        }
        this.modL(r, x);
    };
    Ed25519.prototype.scalarmult = function (p, q, s) {
        var CURVE = this.curve;
        CURVE.set25519(p[0], CURVE.gf0);
        CURVE.set25519(p[1], CURVE.gf1);
        CURVE.set25519(p[2], CURVE.gf1);
        CURVE.set25519(p[3], CURVE.gf0);
        for (var i = 255; i >= 0; --i) {
            var b = (s[(i / 8) | 0] >>> (i & 7)) & 1;
            CURVE.cswap(p, q, b);
            CURVE.add(q, p);
            CURVE.add(p, p);
            CURVE.cswap(p, q, b);
        }
    };
    Ed25519.prototype.scalarbase = function (p, s) {
        var CURVE = this.curve;
        var q = [CURVE.gf(), CURVE.gf(), CURVE.gf(), CURVE.gf()];
        CURVE.set25519(q[0], this.X);
        CURVE.set25519(q[1], this.Y);
        CURVE.set25519(q[2], CURVE.gf1);
        CURVE.M(q[3], this.X, this.Y);
        this.scalarmult(p, q, s);
    };
    /**
     * Generate an ed25519 keypair
     * @param {String} seed A 32 byte cryptographic secure random hexadecimal string. This is basically the secret key
     * @param {Object} Returns sk (Secret key) and pk (Public key) as 32 byte hexadecimal strings
     */
    Ed25519.prototype.generateKeys = function (seed) {
        var pk = new Uint8Array(32);
        var p = [this.curve.gf(), this.curve.gf(), this.curve.gf(), this.curve.gf()];
        var h = (0, blakejs_1.blake2b)(convert_1.default.hex2ab(seed), undefined, 64).slice(0, 32);
        h[0] &= 0xf8;
        h[31] &= 0x7f;
        h[31] |= 0x40;
        this.scalarbase(p, h);
        this.pack(pk, p);
        return {
            privateKey: seed,
            publicKey: convert_1.default.ab2hex(pk),
        };
    };
    /**
     * Convert ed25519 keypair to curve25519 keypair suitable for Diffie-Hellman key exchange
     *
     * @param {KeyPair} keyPair ed25519 keypair
     * @returns {KeyPair} keyPair Curve25519 keypair
     */
    Ed25519.prototype.convertKeys = function (keyPair) {
        var publicKey = convert_1.default.ab2hex(this.curve.convertEd25519PublicKeyToCurve25519(convert_1.default.hex2ab(keyPair.publicKey)));
        if (!publicKey) {
            return null;
        }
        var privateKey = convert_1.default.ab2hex(this.curve.convertEd25519SecretKeyToCurve25519(convert_1.default.hex2ab(keyPair.privateKey)));
        return {
            publicKey: publicKey,
            privateKey: privateKey,
        };
    };
    /**
     * Generate a message signature
     * @param {Uint8Array} msg Message to be signed as byte array
     * @param {Uint8Array} privateKey Secret key as byte array
     * @param {Uint8Array} Returns the signature as 64 byte typed array
     */
    Ed25519.prototype.sign = function (msg, privateKey) {
        var signedMsg = this.naclSign(msg, privateKey);
        var sig = new Uint8Array(64);
        for (var i = 0; i < sig.length; i++) {
            sig[i] = signedMsg[i];
        }
        return sig;
    };
    /**
     * Verify a message signature
     * @param {Uint8Array} msg Message to be signed as byte array
     * @param {Uint8Array} publicKey Public key as byte array
     * @param {Uint8Array} signature Signature as byte array
     * @param {Uint8Array} Returns the signature as 64 byte typed array
     */
    Ed25519.prototype.verify = function (msg, publicKey, signature) {
        var CURVE = this.curve;
        var p = [CURVE.gf(), CURVE.gf(), CURVE.gf(), CURVE.gf()];
        var q = [CURVE.gf(), CURVE.gf(), CURVE.gf(), CURVE.gf()];
        if (signature.length !== 64) {
            return false;
        }
        if (publicKey.length !== 32) {
            return false;
        }
        if (CURVE.unpackNeg(q, publicKey)) {
            return false;
        }
        var ctx = (0, blakejs_1.blake2bInit)(64, undefined);
        (0, blakejs_1.blake2bUpdate)(ctx, signature.subarray(0, 32));
        (0, blakejs_1.blake2bUpdate)(ctx, publicKey);
        (0, blakejs_1.blake2bUpdate)(ctx, msg);
        var k = (0, blakejs_1.blake2bFinal)(ctx);
        this.reduce(k);
        this.scalarmult(p, q, k);
        var t = new Uint8Array(32);
        this.scalarbase(q, signature.subarray(32));
        CURVE.add(p, q);
        this.pack(t, p);
        return util_1.default.compare(signature.subarray(0, 32), t);
    };
    Ed25519.prototype.naclSign = function (msg, secretKey) {
        if (secretKey.length !== 32) {
            throw new Error('bad secret key size');
        }
        var signedMsg = new Uint8Array(64 + msg.length);
        this.cryptoSign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
    };
    Ed25519.prototype.cryptoSign = function (sm, m, n, sk) {
        var CURVE = this.curve;
        var d = new Uint8Array(64);
        var h = new Uint8Array(64);
        var r = new Uint8Array(64);
        var x = new Float64Array(64);
        var p = [CURVE.gf(), CURVE.gf(), CURVE.gf(), CURVE.gf()];
        var i;
        var j;
        var pk = convert_1.default.hex2ab(this.generateKeys(convert_1.default.ab2hex(sk)).publicKey);
        this.curve.cryptoHash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) {
            sm[64 + i] = m[i];
        }
        for (i = 0; i < 32; i++) {
            sm[32 + i] = d[32 + i];
        }
        this.curve.cryptoHash(r, sm.subarray(32), n + 32);
        this.reduce(r);
        this.scalarbase(p, r);
        this.pack(sm, p);
        for (i = 32; i < 64; i++) {
            sm[i] = pk[i - 32];
        }
        this.curve.cryptoHash(h, sm, n + 64);
        this.reduce(h);
        for (i = 0; i < 64; i++) {
            x[i] = 0;
        }
        for (i = 0; i < 32; i++) {
            x[i] = r[i];
        }
        for (i = 0; i < 32; i++) {
            for (j = 0; j < 32; j++) {
                x[i + j] += h[i] * d[j];
            }
        }
        this.modL(sm.subarray(32), x);
        return smlen;
    };
    return Ed25519;
}());
exports.default = Ed25519;
